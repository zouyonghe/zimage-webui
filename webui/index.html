<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Z-Image WebUI</title>
    <link rel="icon" type="image/png" href="./favicon.png?v=3" sizes="256x256" id="app-favicon" />
    <link rel="icon" type="image/x-icon" href="./favicon.ico?v=1" />
    <link rel="stylesheet" href="https://unpkg.com/element-plus@2.8.4/dist/index.css" />
    <script type="importmap">
      {
        "imports": {
          "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
          "element-plus": "https://unpkg.com/element-plus@2.8.4/dist/index.full.mjs"
        }
      }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-base: #0f172a;
        --bg-1: #1e293b;
        --bg-2: #1d1b2f;
        --panel: rgba(255, 255, 255, 0.06);
        --panel-strong: rgba(255, 255, 255, 0.12);
        --panel-soft: rgba(255, 255, 255, 0.04);
        --input-bg: rgba(255, 255, 255, 0.06);
        --accent: #7c3aed;
        --accent-2: #22d3ee;
        --text: #e2e8f0;
        --muted: #94a3b8;
        --success: #4ade80;
        --danger: #f87171;
        --shadow: 0 20px 50px rgba(0, 0, 0, 0.25);
      }

      /* Prevent template flash before Vue mounts */
      [v-cloak] {
        display: none;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Inter", system-ui, -apple-system, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at 20% 20%, var(--bg-1), var(--bg-base) 40%),
          radial-gradient(circle at 80% 30%, var(--bg-2), var(--bg-base) 45%),
          var(--bg-base);
        padding: 32px;
        transition: background 0.3s ease, color 0.3s ease;
      }

      .layout {
        max-width: 1200px;
        margin: 0 auto;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 20px;
        align-items: start;
      }

      header {
        max-width: 1200px;
        margin: 0 auto 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .logo {
        width: 48px;
        height: 48px;
        border-radius: 12px;
        object-fit: contain;
      }

      h1 {
        margin: 0;
        font-size: 26px;
        letter-spacing: 0.5px;
      }

      .badge {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #0b1020;
        padding: 8px 12px;
        border-radius: 12px;
        font-weight: 600;
        box-shadow: 0 10px 40px rgba(124, 58, 237, 0.3);
      }

      .card {
        background: var(--panel);
        border: 1px solid var(--panel-strong);
        border-radius: 16px;
        padding: 18px;
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow);
        transition: background 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
      }

      .card h2 {
        margin: 0 0 12px;
        font-size: 18px;
        letter-spacing: 0.2px;
      }

      label {
        display: block;
        margin: 12px 0 4px;
        color: var(--muted);
        font-size: 14px;
      }

      input,
      textarea,
      select {
        width: 100%;
        background: var(--input-bg);
        border: 1px solid var(--panel-strong);
        border-radius: 12px;
        color: var(--text);
        padding: 10px 12px;
        font-size: 14px;
        transition: border-color 0.15s ease, transform 0.15s ease;
        outline: none;
      }

      /* Make dropdown options readable across themes */
      select,
      .theme-switch select {
        background: var(--panel);
        color: var(--text);
      }

      select option {
        background: var(--bg-base);
        color: var(--text);
      }

      input:focus,
      textarea:focus,
      select:focus {
        border-color: var(--accent);
        transform: translateY(-1px);
      }

      textarea {
        min-height: 110px;
        resize: vertical;
      }

      input[type="range"] {
        width: 100%;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: var(--panel-strong);
        margin: 0;
        padding: 0;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        border: 2px solid #0c1024;
        box-shadow: 0 4px 10px rgba(124, 58, 237, 0.35);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        border: 2px solid #0c1024;
        box-shadow: 0 4px 10px rgba(124, 58, 237, 0.35);
        cursor: pointer;
      }

      .row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
      }

      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      button {
        border: none;
        border-radius: 12px;
        padding: 12px 14px;
        font-weight: 600;
        font-size: 14px;
        cursor: pointer;
        transition: transform 0.1s ease, box-shadow 0.15s ease, opacity 0.15s ease;
        color: #0c1024;
      }

      button.primary {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        box-shadow: 0 10px 30px rgba(124, 58, 237, 0.35);
        color: #0c1024;
      }

      button.secondary {
        background: var(--panel-strong);
        color: var(--text);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
      }

      .status {
        margin-top: 10px;
        font-size: 14px;
        color: var(--muted);
      }

      .progress {
        margin-top: 10px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .progress .loader-small {
        flex: 0 0 auto;
      }

      .progress-bar {
        flex: 1;
        height: 8px;
        border-radius: 999px;
        background: var(--panel-strong);
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        transition: width 0.2s ease;
      }

      .status.error {
        color: var(--danger);
      }

      .status.success {
        color: var(--success);
      }

      .image-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
      }

      .results-card-flex {
        display: flex;
        flex-direction: column;
      }

      .results-scroll-container {
        flex-grow: 1; /* Make it take up available vertical space */
        min-height: 0; /* Prevent flex overflow with scrollable content */
        overflow-y: auto;
        padding-right: 10px; /* For scrollbar space */
        margin-top: 12px; /* To separate from the card header */
      }

      .thumb {
        border: 1px solid var(--panel-strong);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
        background: var(--panel-soft);
        cursor: zoom-in;
        transition: border-color 0.15s ease, box-shadow 0.15s ease, transform 0.1s ease;
      }

      .thumb img {
        width: 100%;
        height: 180px;
        object-fit: cover;
        display: block;
      }

      .thumb .tag {
        position: absolute;
        left: 8px;
        bottom: 8px;
        padding: 4px 8px;
        border-radius: 999px;
        background: rgba(51, 65, 85, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        font-size: 12px;
        color: #fff;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.45);
      }

      .thumb .thumb-close {
        position: absolute;
        top: 6px;
        right: 6px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: none;
        background: rgba(0, 0, 0, 0.45);
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        line-height: 24px;
        text-align: center;
        padding: 0;
        transition: transform 0.15s ease, background 0.15s ease;
      }

      .thumb .thumb-close:hover {
        transform: scale(1.05);
        background: rgba(0, 0, 0, 0.65);
      }

      .placeholder {
        color: var(--muted);
        font-size: 14px;
        text-align: center;
      }

      .loader {
        width: 52px;
        height: 52px;
        border-radius: 50%;
        border: 4px solid var(--panel-strong);
        border-top-color: var(--accent);
        animation: spin 0.8s linear infinite;
      }

      .loader-small {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 3px solid var(--panel-strong);
        border-top-color: var(--accent);
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .meta {
        margin-top: 12px;
        font-size: 13px;
        color: var(--muted);
        line-height: 1.5;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: var(--panel);
        border: 1px solid var(--panel-strong);
        font-size: 12px;
      }

      .preset-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 8px;
      }

      .chip {
        background: var(--panel-soft);
        border: 1px solid var(--panel-strong);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
        font-size: 13px;
        cursor: pointer;
        transition: transform 0.1s ease, border-color 0.15s ease;
      }

      .chip:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
      }

      .history-list {
        display: grid;
        gap: 10px;
      }

      .history-card-flex {
        display: flex;
        flex-direction: column;
      }

      .history-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }

      .history-scroll-container {
        flex-grow: 1;
        min-height: 0;
        overflow-y: auto;
        padding-right: 10px;
      }

      .thumb-info {
        position: absolute;
        left: 8px;
        right: 8px;
        bottom: 8px;
        padding: 8px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.18);
        color: #fff;
        font-size: 12px;
        line-height: 1.4;
        display: grid;
        gap: 2px;
      }

      .corner-progress {
        display: grid;
        gap: 6px;
        width: 200px;
      }

      .card-scroll {
        overflow: auto;
      }

      .history-item {
        display: grid;
        grid-template-columns: 88px 1fr;
        gap: 10px;
        padding: 10px;
        border-radius: 12px;
        border: 1px solid var(--panel-strong);
        background: var(--panel-soft);
        align-items: center;
        cursor: zoom-in;
        transition: border-color 0.15s ease, transform 0.1s ease;
      }

      .history-item:hover {
        border-color: var(--panel-strong);
        transform: translateY(-1px);
      }

      .history-thumb {
        width: 88px;
        height: 88px;
        border-radius: 10px;
        object-fit: cover;
        border: 1px solid var(--panel-strong);
        pointer-events: none;
      }

      .history-meta {
        font-size: 13px;
        color: var(--muted);
        line-height: 1.4;
      }

      .history-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
      }

      .corner-status {
        position: fixed;
        left: 18px;
        bottom: 18px;
        padding: 10px 12px;
        border-radius: 12px;
        background: var(--panel);
        border: 1px solid var(--panel-strong);
        backdrop-filter: blur(10px);
        color: var(--text);
        font-size: 14px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        min-width: 220px;
      }

      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--accent);
        animation: pulse 1.2s ease-in-out infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.3);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
      }

      .preview-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: grid;
        place-items: center;
        padding: 20px;
        z-index: 20;
        backdrop-filter: blur(4px);
      }

      .preview-body {
        background: var(--panel);
        border: 1px solid var(--panel-strong);
        border-radius: 16px;
        padding: 20px;
        max-width: 98vw;
        max-height: 98vh;
        display: grid;
        gap: 12px;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.4);
        position: relative;
      }

      .preview-body img {
        max-width: 96vw;
        max-height: 88vh;
        border-radius: 12px;
        object-fit: contain;
        justify-self: center;
        transition: transform 0.15s ease;
      }

      .preview-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .nav-buttons {
        display: flex;
        gap: 8px;
      }

      .nav-buttons button {
        min-width: 80px;
      }

      .language-switch {
        display: flex;
        background: var(--panel-strong);
        border-radius: 12px;
        padding: 4px;
        gap: 4px;
        flex-wrap: nowrap;
        overflow-x: auto;
      }

      .lang-btn {
        background: transparent;
        border: none;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 14px;
        font-weight: 500;
        color: var(--muted);
        cursor: pointer;
        transition: all 0.2s ease;
        flex: 0 0 auto;
        white-space: nowrap;
      }

      .lang-btn.active {
        background: var(--accent);
        color: #0c1024;
      }

      .lang-btn:hover:not(.active) {
        background: var(--panel);
        color: var(--text);
      }

      .theme-switch {
        position: relative;
        display: inline-flex;
      }

      .theme-trigger {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 9px 10px;
        background: var(--bg-base);
        border: 1px solid var(--panel-strong);
        border-radius: 14px;
        color: var(--text);
        cursor: pointer;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.2);
        transition: transform 0.12s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        min-width: 120px;
        width: auto;
      }

      .theme-trigger:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.25);
      }

      .theme-trigger .theme-dot {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 1px solid var(--panel-strong);
        box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.05);
      }

      .theme-trigger .theme-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        flex: 1;
        text-align: center;
      }

      .theme-trigger small {
        color: var(--muted);
        font-size: 12px;
      }

      .theme-trigger strong {
        font-size: 14px;
        letter-spacing: 0.2px;
      }

      .theme-trigger .caret {
        opacity: 0.7;
        font-size: 14px;
        transition: transform 0.2s ease, opacity 0.2s ease;
      }

      .theme-switch.open .theme-trigger .caret {
        transform: rotate(180deg);
      }

      .theme-dropdown {
        position: absolute;
        right: 0;
        top: calc(100% + 8px);
        width: 100%;
        background: var(--bg-base);
        border: 1px solid var(--panel-strong);
        border-radius: 14px;
        box-shadow: var(--shadow);
        padding: 8px;
        display: grid;
        gap: 6px;
        z-index: 10;
      }

      .theme-option {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--panel-strong);
        cursor: pointer;
        transition: transform 0.1s ease, border-color 0.2s ease, background 0.2s ease;
        width: 100%;
      }

      .theme-option:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        background: var(--panel-soft);
      }

      .theme-option.active {
        border-color: var(--accent);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
      }

      .theme-swatch {
        width: 38px;
        height: 26px;
        border-radius: 8px;
        border: 1px solid var(--panel-strong);
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.1);
        margin-left: auto;
      }

      .theme-name {
        font-weight: 600;
        font-size: 14px;
        color: var(--text);
        flex: 1;
        text-align: center;
      }

      .upscale-range {
        width: 100%;
        display: block;
      }

      .auto-upscale-active {
        background: linear-gradient(135deg, var(--accent), var(--accent-2)) !important;
        color: #0c1024 !important;
        box-shadow: 0 10px 30px rgba(124, 58, 237, 0.35);
      }

      input[type="range"] {
        width: 100%;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: var(--panel-strong);
        margin: 0;
        padding: 0;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        border: 2px solid #0c1024;
        box-shadow: 0 4px 10px rgba(124, 58, 237, 0.35);
        cursor: pointer;
      }

      input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        border: 2px solid #0c1024;
        box-shadow: 0 4px 10px rgba(124, 58, 237, 0.35);
        cursor: pointer;
      }

      .magnifier-lens {
        position: fixed;
        pointer-events: none;
        border-radius: 50%;
        border: 2px solid var(--accent);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        z-index: 30;
        backdrop-filter: blur(0px);
        overflow: hidden;
      }

      @media (max-width: 720px) {
        body {
          padding: 18px;
        }
        header {
          flex-direction: column;
          align-items: flex-start;
        }
        .image-frame {
          aspect-ratio: 1 / 1;
        }
      }
    </style>
  </head>
  <body>
    <div id="app" v-cloak>
      <header>
        <div style="display: flex; align-items: center; gap: 12px">
          <img class="logo" src="./favicon.png" alt="Z-Image Logo" />
          <h1>Z-Image WebUI</h1>
        </div>
        <div style="display: flex; align-items: center; gap: 12px">
          <div class="theme-switch" ref="themeSwitchRef" :class="{ open: themeMenuOpen }">
            <button class="theme-trigger" type="button" @click.stop="toggleThemeMenu">
              <span class="theme-dot" :style="activeThemeSwatch"></span>
              <div class="theme-text">
                <small>{{ t('theme.label') }}</small>
                <strong>{{ activeThemeLabel }}</strong>
              </div>
              <span class="caret">v</span>
            </button>
            <div class="theme-dropdown" v-if="themeMenuOpen" :style="{ width: themeControlWidth, minWidth: themeControlWidth }">
              <div
                class="theme-option"
                v-for="theme in themeOptions"
                :key="theme.key"
                :class="{ active: activeTheme === theme.key }"
                @click.stop="selectTheme(theme.key)"
              >
                <div class="theme-swatch" :style="getThemeSwatch(theme.key)"></div>
                <div class="theme-name">{{ t(theme.labelKey) }}</div>
              </div>
            </div>
          </div>
          <div class="language-switch">
            <button
              class="lang-btn"
              :class="{ active: currentLang === 'zh' }"
              @click="switchLanguage('zh')"
            >
              中文
            </button>
            <button
              class="lang-btn"
              :class="{ active: currentLang === 'en' }"
              @click="switchLanguage('en')"
            >
              EN
            </button>
            <button
              class="lang-btn"
              :class="{ active: currentLang === 'ja' }"
              @click="switchLanguage('ja')"
            >
              日本語
            </button>
          </div>
        </div>
      </header>

      <main class="layout">
      <section class="card" ref="promptCardRef">
        <h2>{{ t('prompt.title') }}</h2>
        <label for="prompt">{{ t('prompt.title') }}</label>
        <textarea
          id="prompt"
          v-model="prompt"
          :placeholder="t('prompt.placeholder')"
        ></textarea>

        <label for="negative">{{ t('negative.title') }}</label>
        <textarea
          id="negative"
          v-model="negativePrompt"
          :placeholder="t('negative.placeholder')"
        ></textarea>

        <div class="row">
          <div>
            <label for="steps">{{ t('steps.label') }} {{ steps }}</label>
            <input
              type="range"
              id="steps"
              v-model.number="steps"
              min="4"
              max="30"
              step="1"
              title="控制推理步数，步数越多越精细但耗时更长"
            />
          </div>
          <div>
            <label for="guidance">{{ t('guidance.label') }} {{ guidance.toFixed(1) }}</label>
            <input
              type="range"
              id="guidance"
              v-model.number="guidance"
              min="0"
              max="10"
              step="0.5"
              title="提示词引导强度，数值越高越贴合提示词，但过高可能产生伪影"
            />
          </div>
        </div>

          <div class="row">
          <div>
            <label for="height">{{ t('height.label') }}</label>
            <input
              type="number"
              id="height"
              v-model.number="height"
              min="512"
              max="1024"
              step="64"
              title="输出图片高度，分辨率越大越耗时与显存"
              @change="snapDimensions"
            />
          </div>
          <div>
            <label for="width">{{ t('width.label') }}</label>
            <input
              type="number"
              id="width"
              v-model.number="width"
              min="512"
              max="1024"
              step="64"
              title="输出图片宽度，分辨率越大越耗时与显存"
              @change="snapDimensions"
            />
          </div>
          <div>
            <label for="seed">{{ t('seed.label') }}</label>
            <input
              type="number"
              id="seed"
              v-model="seed"
              :placeholder="t('seed.placeholder')"
              title="固定种子以复现同一结果；留空自动随机"
            />
          </div>
          <div>
            <label for="batchCount">{{ t('batchCount.label') }}</label>
            <input
              type="number"
              id="batchCount"
              v-model.number="batchCount"
              min="1"
              max="10"
              step="1"
              title="一次点击连续生成多张图片，最多 10 张"
            />
          </div>
        </div>

        <div>
          <label>{{ t('ratio.label') }}</label>
          <select v-model="selectedRatio" @change="onRatioChange">
            <option v-for="ratio in ratios" :key="ratio.label" :value="ratio.label">
              {{ ratio.label }} ({{ ratio.width }}×{{ ratio.height }})
            </option>
          </select>
        </div>
        <div>
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <div style="flex:1; min-width: 200px;">
              <label>{{ t('upscale.scale') }}: {{ upscaleScale.toFixed(1) }}×</label>
              <input
                class="upscale-range"
                type="range"
                min="1"
                max="4"
                step="0.1"
                v-model.number="upscaleScale"
                :disabled="loading || batchRunning || upscaleLoading"
              />
            </div>
          </div>
        </div>

        <div class="actions">
        <button class="primary" :disabled="isGenerateDisabled" @click="generate()">
          {{ loading ? t('generate.loading') : t('generate.button') }}
        </button>
          <button
            class="secondary"
            :disabled="!(loading || batchRunning) || stopRequested"
            @click="requestStop"
          >
            {{ stopRequested ? t('stop.requested') : t('stop.button') }}
          </button>
          <button class="secondary" :disabled="loading || batchRunning" @click="randomizeSeed">{{ t('randomSeed.button') }}</button>
          <button
            class="secondary"
            :class="{ primary: autoUpscaleEnabled, 'auto-upscale-active': autoUpscaleEnabled }"
            :disabled="upscaleLoading"
            @click="toggleAutoUpscale"
          >
            {{ t('upscale.autoLabel') }}
          </button>
          <button class="secondary" :disabled="loading || batchRunning" @click="resetPrompt">{{ t('reset.button') }}</button>
          <button class="secondary" :disabled="!image || loading || batchRunning" @click="downloadImage">{{ t('save.button') }}</button>
        </div>

      <!-- meta pills removed per request -->
      </section>

      <section class="card card-scroll results-card-flex" :style="syncedCardStyle">
        <div style="display:flex; align-items:center; gap:10px; justify-content: space-between; flex-wrap: wrap;">
          <h2 style="margin:0;">{{ t('results.title') }}</h2>
        </div>
        <div class="results-scroll-container">
          <div v-if="results.length" class="image-grid">
            <div
              class="thumb"
              v-for="(item, idx) in results"
              :key="item.id"
              @click="openPreview(idx)"
            >
              <button class="thumb-close" @click.stop="deleteResult(item.id)">×</button>
              <img :src="item.image" :alt="`${t('results.title')} ${idx + 1}`" />
              <div class="tag">{{ item.meta.width }}×{{ item.meta.height }}</div>
            </div>
          </div>
          <div v-else class="placeholder">
            {{ t('results.placeholder') }}
          </div>
          <div
            v-if="loading || batchRunning || upscaleLoading"
            style="margin-top: 12px; display: grid; place-items: center; gap: 6px;"
          >
            <div class="loader"></div>
            <div class="status" style="margin:0; text-align:center;">
              {{ upscaleProgressLabel || imageProgressLabel || statusLabel }}
            </div>
          </div>
        </div>
      </section>

      <section class="card card-scroll history-card-flex" :style="syncedCardStyle">
        <div class="history-header">
          <h2>{{ t('history.title') }}</h2>
          <button class="secondary" :disabled="history.length === 0" @click="clearHistory">{{ t('history.clear') }}</button>
        </div>
        <div class="history-scroll-container">
          <div v-if="history.length === 0" class="placeholder">{{ t('history.placeholder') }}</div>
          <div v-else class="history-list">
            <div
              class="history-item"
              v-for="(item, idx) in history"
              :key="item.id"
              @click="openPreview(idx, 'history')"
              :title="t('history.title')"
            >
              <img class="history-thumb" :src="item.image" alt="历史缩略图" />
              <div>
                <div class="history-meta">
                  {{ item.prompt }}
                <div>{{ t('history.steps') }}: {{ item.steps }} | {{ t('history.guidance') }}: {{ item.guidance }} | {{ t('history.seed') }}: {{ item.seed ?? t('seed.placeholder') }}</div>
                <div>{{ t('history.size') }}: {{ item.width }}×{{ item.height }}</div>
                <div v-if="item.negative">{{ t('history.negative') }}: {{ item.negative }}</div>
                <div v-if="item.scale && item.scale !== 1">{{ t('meta.scale') }}: {{ item.scale }}×</div>
              </div>
              <div class="history-actions">
                <button class="secondary" @click.stop="applyHistory(item)">{{ t('history.refill') }}</button>
                <button class="secondary" @click.stop="regenerate(item)">{{ t('history.regenerate') }}</button>
                <button class="secondary" @click.stop="deleteHistory(item.id)">{{ t('history.delete') }}</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>
        <div class="corner-status">
          <div class="dot" :style="{ background: statusTone }"></div>
          <div style="display:grid; gap:6px; min-width: 180px;">
            <div>{{ statusLabel }}</div>
            <div class="corner-progress" v-if="overallProgressActive">
              <div class="progress-bar">
                <div class="progress-fill" :style="{ width: overallProgressPercent + '%' }"></div>
              </div>
              <div style="font-size:12px; color: var(--muted); text-align:right;">{{ overallProgressLabel }}</div>
            </div>
          </div>
        </div>

      <div v-if="previewOpen" class="preview-overlay" @click.self="closePreview" @wheel.prevent="onPreviewWheel">
          <div class="preview-body" @wheel.prevent="onPreviewWheel">
          <img
            :src="(currentPreviewItem && currentPreviewItem.image) || selectedImage || results[selectedIndex]?.image || results[0]?.image"
            :alt="t('results.title')"
            @mousemove="onMagnifierMove"
            @mouseleave="hideMagnifier"
            @click.left.stop="nextImage"
            @contextmenu.prevent.stop="prevImage"
          />
          <div
            class="thumb-info"
            v-if="showInfoOverlay && currentPreviewItem"
            style="max-width: 340px; top: 12px; right: 12px; left: auto; bottom: auto;"
          >
            <div>{{ t('meta.size') }}: {{ currentPreviewItem.meta?.width }}×{{ currentPreviewItem.meta?.height }}</div>
            <div>{{ t('meta.steps') }}: {{ currentPreviewItem.meta?.steps ?? steps }}</div>
            <div>{{ t('meta.guidance') }}: {{ currentPreviewItem.meta?.guidance ?? guidance }}</div>
            <div>{{ t('meta.seed') }}: {{ currentPreviewItem.meta?.seed ?? t('seed.placeholder') }}</div>
            <div v-if="currentPreviewItem.meta?.prompt">{{ t('prompt.title_simple') }}: {{ currentPreviewItem.meta.prompt }}</div>
            <div v-if="currentPreviewItem.meta?.negative_prompt">{{ t('negative.title') }}: {{ currentPreviewItem.meta.negative_prompt }}</div>
          </div>
          <div class="preview-actions">
            <div class="nav-buttons">
              <button class="secondary" @click.stop="prevImage" :disabled="!hasPrev">{{ t('preview.previous') }}</button>
              <button class="secondary" @click.stop="nextImage" :disabled="!hasNext">{{ t('preview.next') }}</button>
            </div>
            <div style="display:flex; gap:8px; margin-left:auto;">
              <button
                class="secondary"
                :class="{ 'auto-upscale-active': showInfoOverlay }"
                style="padding: 10px 12px; min-width: 100px;"
                @click.stop="showInfoOverlay = !showInfoOverlay"
              >
                {{ t('preview.info') }}
              </button>
              <button
                class="secondary"
                :class="{ 'auto-upscale-active': magnifierEnabled }"
                :disabled="magnifierDisabled"
                @click.stop="toggleMagnifier"
              >
                {{ t('preview.magnifier') }}
              </button>
              <button
                class="secondary"
                :disabled="upscaleDisabled"
                @click.stop="() => upscaleImage({ auto: true })"
              >
                {{ upscaleLoading ? t('upscale.running') : t('upscale.button') }}
              </button>
              <div class="status" style="margin:0;" :class="{'error': upscaleError}">
                <span v-if="upscaleError">⚠ {{ upscaleError }}</span>
              </div>
              <button class="secondary" @click.stop="downloadPreviewImage">{{ t('preview.download') }}</button>
              <button class="secondary" @click.stop="closePreview">{{ t('preview.close') }}</button>
            </div>
          </div>
        </div>
        </div>
      <div
        v-if="magnifierVisible && magnifierEnabled"
        class="magnifier-lens"
        :style="magnifierStyle"
      ></div>
      </main>
    </div>

    <script type="module">
      import { createApp, ref, computed, onMounted, onBeforeUnmount, watch, nextTick } from "vue";
      import ElementPlus from "element-plus";
      const DEFAULT_PROMPT = "a cat sitting on a chair, high quality, detailed";
      const STREAM_TIMEOUT_MS = 30000; // 30 seconds per generate stream request
      const UPSCALE_TIMEOUT_MS = 30000; // 30 seconds per upscale stream request

      createApp({
        setup() {
          // 翻译数据
          const translations = {
            zh: {
              'header.subtitle': '在线生成高质量图片',
              'prompt.title': '提示词与参数',
              'prompt.title_simple': '提示词',
              'prompt.placeholder': '描述你想生成的画面...',
              'negative.title': '负面提示词',
              'negative.placeholder': '不想出现的元素，例如：low quality, blurry, watermark',
              'steps.label': '采样步数',
              'guidance.label': '引导强度',
              'height.label': '高度 (px)',
              'width.label': '宽度 (px)',
              'seed.label': '随机种子 (可选)',
              'seed.placeholder': '留空则随机',
              'batchCount.label': '连续生成张数',
              'ratio.label': '画幅预设',
              'generate.button': '生成图片',
              'generate.loading': '正在生成',
              'randomSeed.button': '随机种子',
              'reset.button': '重置默认',
              'save.button': '保存图片',
              'results.title': '生成结果',
              'results.placeholder': '暂无图片，输入提示词后点击"生成图片"',
              'history.title': '历史记录',
              'history.clear': '清空',
              'history.placeholder': '暂无历史记录',
              'history.refill': '回填',
              'history.regenerate': '再次生成',
              'history.delete': '删除',
              'preview.previous': '上一张',
              'preview.next': '下一张',
              'preview.download': '下载图片',
              'preview.close': '关闭',
              'preview.magnifier': '放大镜',
              'preview.info': '显示信息',
              'upscale.title': '高分辨率放大',
              'upscale.scale': '高分放大倍率',
              'upscale.button': '高分放大',
              'upscale.running': '正在放大',
              'upscale.noImage': '暂无可放大的图片',
              'upscale.autoLabel': '自动放大',
              'status.ready': '已就绪',
              'status.loading': '模型加载中...',
              'status.generating': '正在生成...',
              'status.batchGenerating': '正在生成...',
              'status.stopRequested': '已请求停止，当前图片完成后终止',
              'status.loadFailed': '加载失败',
              'status.completed': '生成完成',
              'stop.button': '停止生成',
              'stop.requested': '等待当前完成后停止',
              'meta.device': '设备',
              'meta.steps': '步数',
              'meta.guidance': '引导',
              'meta.size': '尺寸',
              'meta.negative': '负面',
              'meta.seed': '种子',
              'meta.scale': '放大',
              'history.steps': '步数',
              'history.guidance': '引导',
              'history.seed': '种子',
              'history.size': '尺寸',
              'history.negative': '负面',
            'theme.label': '主题',
              'theme.midnight': '深蓝',
              'theme.dawn': '晨光',
              'theme.sunset': '落日',
              'theme.glacier': '冰蓝',
              'theme.forest': '森野'
            },
            en: {
              'header.subtitle': 'Generate high-quality images online',
              'prompt.title': 'Prompt & Parameters',
              'prompt.title_simple': 'Prompt',
              'prompt.placeholder': 'Describe the image you want to generate...',
              'negative.title': 'Negative Prompt',
              'negative.placeholder': 'Elements to avoid, e.g.: low quality, blurry, watermark',
              'steps.label': 'Sampling Steps',
              'guidance.label': 'Guidance Scale',
              'height.label': 'Height (px)',
              'width.label': 'Width (px)',
              'seed.label': 'Random Seed (Optional)',
              'seed.placeholder': 'Leave empty for random',
              'batchCount.label': 'Batch Count',
              'ratio.label': 'Aspect Ratio Presets',
              'generate.button': 'Generate Image',
              'generate.loading': 'Generating',
              'randomSeed.button': 'Random Seed',
              'reset.button': 'Reset to Default',
              'save.button': 'Save Image',
              'results.title': 'Generated Results',
              'results.placeholder': 'No images yet. Enter a prompt and click "Generate Image"',
              'history.title': 'History',
              'history.clear': 'Clear',
              'history.placeholder': 'No history yet',
              'history.refill': 'Refill',
              'history.regenerate': 'Regenerate',
              'history.delete': 'Delete',
              'preview.previous': 'Previous',
              'preview.next': 'Next',
              'preview.download': 'Download Image',
              'preview.close': 'Close',
              'preview.magnifier': 'Magnifier',
              'preview.info': 'Show info',
              'upscale.title': 'High-Res Upscale',
              'upscale.scale': 'Hi-Res Scale',
              'upscale.button': 'Hi-Res Upscale',
              'upscale.running': 'Upscaling',
              'upscale.noImage': 'No image to upscale yet',
              'upscale.autoLabel': 'Auto Upscale',
              'status.ready': 'Ready',
              'status.loading': 'Model loading...',
              'status.generating': 'Generating...',
              'status.batchGenerating': 'Generating...',
              'status.stopRequested': 'Stop requested; will halt after current image',
              'status.loadFailed': 'Load failed',
              'status.completed': 'Generation completed',
              'stop.button': 'Stop',
              'stop.requested': 'Stopping after current image',
              'meta.device': 'Device',
              'meta.steps': 'Steps',
              'meta.guidance': 'Guidance',
              'meta.size': 'Size',
              'meta.negative': 'Negative',
              'meta.seed': 'Seed',
              'meta.scale': 'Upscale',
              'history.steps': 'Steps',
              'history.guidance': 'Guidance',
              'history.seed': 'Seed',
              'history.size': 'Size',
              'history.negative': 'Negative',
              'theme.label': 'Theme',
              'theme.midnight': 'Midnight (Dark)',
              'theme.dawn': 'Dawn (Light)',
              'theme.sunset': 'Sunset Neon (Dark)',
              'theme.glacier': 'Glacier (Light)',
              'theme.forest': 'Forest (Dark)'
            },
            ja: {
              'header.subtitle': '高品質な画像をオンライン生成',
              'prompt.title': 'プロンプトとパラメータ',
              'prompt.title_simple': 'プロンプト',
              'prompt.placeholder': '生成したい画像を説明してください...',
              'negative.title': 'ネガティブプロンプト',
              'negative.placeholder': '含めたくない要素 例: low quality, blurry, watermark',
              'steps.label': 'サンプリングステップ',
              'guidance.label': 'ガイダンス強度',
              'height.label': '高さ (px)',
              'width.label': '幅 (px)',
              'seed.label': 'ランダムシード (任意)',
              'seed.placeholder': '空ならランダム',
              'batchCount.label': '連続生成枚数',
              'ratio.label': 'アスペクト比プリセット',
              'generate.button': '画像を生成',
              'generate.loading': '生成中',
              'randomSeed.button': 'ランダムシード',
              'reset.button': 'デフォルトにリセット',
              'save.button': '画像を保存',
              'results.title': '生成結果',
              'results.placeholder': 'まだ画像がありません。プロンプトを入力して「画像を生成」を押してください',
              'history.title': '履歴',
              'history.clear': 'クリア',
              'history.placeholder': '履歴がありません',
              'history.refill': '再入力',
              'history.regenerate': '再生成',
              'history.delete': '削除',
              'preview.previous': '前へ',
              'preview.next': '次へ',
              'preview.download': '画像をダウンロード',
              'preview.close': '閉じる',
              'preview.magnifier': 'ルーペ',
              'preview.info': '情報表示',
              'upscale.title': '高解像度アップスケール',
              'upscale.scale': '高解像度倍率',
              'upscale.button': '高解像度アップスケール',
              'upscale.running': 'アップスケール中',
              'upscale.noImage': 'アップスケールできる画像がありません',
              'upscale.autoLabel': '自動アップスケール',
              'status.ready': '準備完了',
              'status.loading': 'モデル読み込み中...',
              'status.generating': '生成中...',
              'status.batchGenerating': '生成中...',
              'status.stopRequested': '停止をリクエストしました。現在の画像が終わったら停止',
              'status.loadFailed': '読み込み失敗',
              'status.completed': '生成完了',
              'stop.button': '停止',
              'stop.requested': 'この画像の後で停止',
              'meta.device': 'デバイス',
              'meta.steps': 'ステップ',
              'meta.guidance': 'ガイダンス',
              'meta.size': 'サイズ',
              'meta.negative': 'ネガティブ',
              'meta.seed': 'シード',
              'meta.scale': 'スケール',
              'history.steps': 'ステップ',
              'history.guidance': 'ガイダンス',
              'history.seed': 'シード',
              'history.size': 'サイズ',
              'history.negative': 'ネガティブ',
              'theme.label': 'テーマ',
              'theme.midnight': 'ミッドナイト (ダーク)',
              'theme.dawn': '夜明け (ライト)',
              'theme.sunset': 'サンセット (ダーク)',
              'theme.glacier': 'グレイシャー (ライト)',
              'theme.forest': 'フォレスト (ダーク)'
            }
          };
          const themes = {
            midnight: {
              mode: "dark",
              vars: {
                "bg-base": "#0f172a",
                "bg-1": "#1e293b",
                "bg-2": "#1d1b2f",
                panel: "rgba(255, 255, 255, 0.06)",
                "panel-strong": "rgba(255, 255, 255, 0.12)",
                "panel-soft": "rgba(255, 255, 255, 0.04)",
                "input-bg": "rgba(255, 255, 255, 0.06)",
                accent: "#7c3aed",
                "accent-2": "#22d3ee",
                text: "#e2e8f0",
                muted: "#94a3b8",
                success: "#4ade80",
                danger: "#f87171",
                shadow: "0 20px 50px rgba(0, 0, 0, 0.25)",
              },
            },
            dawn: {
              mode: "light",
              vars: {
                "bg-base": "#fff7ed",
                "bg-1": "#fef3c7",
                "bg-2": "#ffe4e6",
                panel: "rgba(255, 255, 255, 0.92)",
                "panel-strong": "rgba(15, 23, 42, 0.12)",
                "panel-soft": "rgba(15, 23, 42, 0.04)",
                "input-bg": "rgba(255, 255, 255, 0.92)",
                accent: "#f97316",
                "accent-2": "#fbbf24",
                text: "#0f172a",
                muted: "#475569",
                success: "#16a34a",
                danger: "#dc2626",
                shadow: "0 14px 34px rgba(15, 23, 42, 0.18)",
              },
            },
            sunset: {
              mode: "dark",
              vars: {
                "bg-base": "#1a1325",
                "bg-1": "#2b1538",
                "bg-2": "#3b1225",
                panel: "rgba(255, 255, 255, 0.05)",
                "panel-strong": "rgba(255, 255, 255, 0.12)",
                "panel-soft": "rgba(255, 255, 255, 0.04)",
                "input-bg": "rgba(255, 255, 255, 0.06)",
                accent: "#fb7185",
                "accent-2": "#f97316",
                text: "#f8fafc",
                muted: "#e2e8f0",
                success: "#34d399",
                danger: "#f87171",
                shadow: "0 20px 50px rgba(0, 0, 0, 0.35)",
              },
            },
            glacier: {
              mode: "light",
              vars: {
                "bg-base": "#e0f2fe",
                "bg-1": "#bae6fd",
                "bg-2": "#c7d2fe",
                panel: "rgba(255, 255, 255, 0.94)",
                "panel-strong": "rgba(15, 23, 42, 0.12)",
                "panel-soft": "rgba(15, 23, 42, 0.05)",
                "input-bg": "rgba(255, 255, 255, 0.92)",
                accent: "#0ea5e9",
                "accent-2": "#22d3ee",
                text: "#0f172a",
                muted: "#334155",
                success: "#16a34a",
                danger: "#e11d48",
                shadow: "0 14px 32px rgba(15, 23, 42, 0.16)",
              },
            },
            forest: {
              mode: "dark",
              vars: {
                "bg-base": "#0b1a16",
                "bg-1": "#123126",
                "bg-2": "#0f2a2b",
                panel: "rgba(255, 255, 255, 0.05)",
                "panel-strong": "rgba(255, 255, 255, 0.12)",
                "panel-soft": "rgba(255, 255, 255, 0.04)",
                "input-bg": "rgba(255, 255, 255, 0.06)",
                accent: "#10b981",
                "accent-2": "#34d399",
                text: "#d1fae5",
                muted: "#9ca3af",
                success: "#34d399",
                danger: "#f87171",
                shadow: "0 20px 50px rgba(0, 0, 0, 0.35)",
              },
            },
          };
      const applyTheme = (key) => {
        const theme = themes[key] || themes.midnight;
        Object.entries(theme.vars).forEach(([name, value]) => {
          document.documentElement.style.setProperty(`--${name}`, value);
        });
        document.documentElement.setAttribute("data-theme", key);
        document.documentElement.style.colorScheme = theme.mode === "light" ? "light" : "dark";
        const icon = document.querySelector('link#app-favicon');
        if (icon) {
          const url = new URL(icon.href, window.location.href);
          // bump cache buster to force reload if needed
          url.searchParams.set("t", Date.now().toString(36));
          icon.href = url.pathname + url.search;
        }
      };
          const prompt = ref(DEFAULT_PROMPT);
          const negativePrompt = ref("");
          const steps = ref(9);
          const guidance = ref(0);
          const height = ref(512);
          const width = ref(512);
          const seed = ref("");
          const batchCount = ref(1);
          const batchRunning = ref(false);
          const batchCursor = ref(0);
          const batchTotal = ref(0);
          const stopRequested = ref(false);
          const loading = ref(false);
          const modelLoading = ref(true);
          const modelError = ref("");
          const error = ref("");
          const stepProgress = ref({ current: 0, total: 0 });
          const meta = ref(null);
          const results = ref([]);
          const image = ref("");
          const selectedImage = ref("");
          const selectedIndex = ref(0);
          const previewSource = ref("results");
          const previewOpen = ref(false);
          const magnifierVisible = ref(false);
          const magnifierSize = ref(200);
          const magnifierZoom = ref(2);
          const magnifierImage = ref("");
          const magnifierData = ref({ bgX: 0, bgY: 0, naturalWidth: 0, naturalHeight: 0, clientX: 0, clientY: 0 });
          const magnifierEnabled = ref(false);
          const magnifierDisabled = computed(() => loading.value || batchRunning.value || upscaleLoading.value);
          let magnifierRAF = null;
          let magnifierPending = null;
          const promptCardRef = ref(null);
          const promptCardHeight = ref(0);
          let promptResizeObserver = null;
          const measurePromptHeight = () => {
            if (!promptCardRef.value) return;
            const rect = promptCardRef.value.getBoundingClientRect();
            const measured = Math.max(rect.height || 0, promptCardRef.value.scrollHeight || 0);
            const fallback = Math.max(360, (window.innerHeight || 0) - 180);
            const next = Math.max(measured, fallback);
            if (Math.abs((promptCardHeight.value || 0) - next) > 1) {
              promptCardHeight.value = next;
            }
          };
          const syncCardHeightSoft = () => {
            requestAnimationFrame(() => {
              measurePromptHeight();
              setTimeout(measurePromptHeight, 120);
              setTimeout(measurePromptHeight, 320);
            });
          };
          const totalWorkUnits = ref(0);
          const completedWorkUnits = ref(0);
          const currentWorkPhase = ref("");
          const finalizeWork = () => {
            if (totalWorkUnits.value <= 0) return;
            completedWorkUnits.value = Math.max(completedWorkUnits.value, totalWorkUnits.value);
            totalWorkUnits.value = 0;
            currentWorkPhase.value = "";
          };
          const showInfoOverlay = ref(false);
          const upscaleScale = ref(2.0);
          const upscaleLoading = ref(false);
          const upscaleError = ref("");
          const upscaleStepProgress = ref({ current: 0, total: 0 });
          const autoUpscaleEnabled = ref(false);
          const lastAutoBaseId = ref("");
          const history = ref([]);
          const selectedRatio = ref("1:1 512");
          let fakeProgressTimer = null;
          const clearFakeProgress = () => {
            if (fakeProgressTimer) {
              clearInterval(fakeProgressTimer);
              fakeProgressTimer = null;
            }
          };
          const startFakeProgress = (targetSteps) => {
            clearFakeProgress();
            const total = targetSteps || steps.value || 10;
            let current = 0;
            fakeProgressTimer = setInterval(() => {
              current = Math.min(total * 0.9, (stepProgress.value.current || 0) + 1);
              stepProgress.value = { current, total };
            }, 500);
          };
          
          // 语言相关状态
          const currentLang = ref(localStorage.getItem('zimage-lang') || 'zh');
          
          // 翻译函数
          const t = (key) => {
            return translations[currentLang.value][key] || key;
          };
          
          // 语言切换函数
          const switchLanguage = (lang) => {
            currentLang.value = lang;
            localStorage.setItem('zimage-lang', lang);
          };

          const themeOptions = [
            { key: "midnight", labelKey: "theme.midnight" },
            { key: "dawn", labelKey: "theme.dawn" },
            { key: "sunset", labelKey: "theme.sunset" },
            { key: "glacier", labelKey: "theme.glacier" },
            { key: "forest", labelKey: "theme.forest" },
          ];
          const activeTheme = ref(localStorage.getItem('zimage-theme') || 'midnight');
          const themeMenuOpen = ref(false);
          const themeSwitchRef = ref(null);
          const themeControlWidth = ref('auto');
          const syncThemeWidth = () => {
            const el = themeSwitchRef.value;
            if (!el) return;
            const btn = el.querySelector('.theme-trigger');
            const width = (btn && btn.offsetWidth) || el.offsetWidth;
            if (width) {
              themeControlWidth.value = `${width}px`;
            }
          };
          const getThemeSwatch = (key) => {
            const theme = themes[key];
            if (!theme) return {};
            const accent = theme.vars.accent;
            const accent2 = theme.vars["accent-2"] || accent;
            return { background: `linear-gradient(135deg, ${accent}, ${accent2})` };
          };
          const activeThemeSwatch = computed(() => getThemeSwatch(activeTheme.value));
          const activeThemeLabel = computed(() => {
            const match = themeOptions.find((item) => item.key === activeTheme.value);
            return match ? t(match.labelKey) : t('theme.label');
          });
          const toggleThemeMenu = () => {
            themeMenuOpen.value = !themeMenuOpen.value;
            nextTick(syncThemeWidth);
          };
          const closeThemeMenu = () => {
            themeMenuOpen.value = false;
          };
          const selectTheme = (key) => {
            activeTheme.value = key;
            closeThemeMenu();
          };
          const handleClickOutside = (event) => {
            if (!themeSwitchRef.value) return;
            if (!themeSwitchRef.value.contains(event.target)) {
              closeThemeMenu();
            }
          };
          // 同步页面 lang 属性，便于切换语种
          watch(
            currentLang,
            (lang) => {
              document.documentElement.lang = lang === "zh" ? "zh-CN" : "en";
              nextTick(syncThemeWidth);
              nextTick(syncCardHeightSoft);
            },
            { immediate: true }
          );
          watch(
            activeThemeLabel,
            () => nextTick(syncThemeWidth)
          );
          watch(
            () => [results.value.length, loading.value, batchRunning.value, upscaleLoading.value],
            () => {
              nextTick(syncCardHeightSoft);
            }
          );
          onMounted(() => {
            document.addEventListener('click', handleClickOutside);
            nextTick(syncThemeWidth);
            window.addEventListener('resize', syncThemeWidth);
            nextTick(syncCardHeightSoft);
            window.addEventListener('resize', syncCardHeightSoft);
            if (document.fonts && document.fonts.ready) {
              document.fonts.ready.then(() => syncCardHeightSoft());
            }
            if (window.ResizeObserver) {
              promptResizeObserver = new ResizeObserver(() => syncCardHeightSoft());
              if (promptCardRef.value) {
                promptResizeObserver.observe(promptCardRef.value);
              }
            }
            setTimeout(syncCardHeightSoft, 80);
            setTimeout(syncCardHeightSoft, 200);
            setTimeout(syncCardHeightSoft, 400);
          });
          onBeforeUnmount(() => {
            document.removeEventListener('click', handleClickOutside);
            window.removeEventListener('resize', syncThemeWidth);
            window.removeEventListener('resize', syncCardHeightSoft);
            if (promptResizeObserver && promptResizeObserver.disconnect) {
              promptResizeObserver.disconnect();
            }
          });
          watch(
            activeTheme,
            (key) => {
              applyTheme(key);
              localStorage.setItem('zimage-theme', key);
              nextTick(syncThemeWidth);
              nextTick(syncCardHeightSoft);
            },
            { immediate: true }
          );
          const syncedCardStyle = computed(() => {
            if (!promptCardHeight.value) return {};
            const h = promptCardHeight.value;
            return { height: `${h}px`, minHeight: `${h}px`, overflow: "auto" };
          });
          watch(
            () => [
              prompt.value,
              negativePrompt.value,
              steps.value,
              guidance.value,
              height.value,
              width.value,
              seed.value,
              batchCount.value,
              selectedRatio.value,
              upscaleScale.value,
              autoUpscaleEnabled.value,
            ],
            () => nextTick(syncCardHeightSoft)
          );
          watch(
            () => results.value.length,
            () => nextTick(syncCardHeightSoft)
          );
          watch(
            () => history.value.length,
            () => nextTick(syncCardHeightSoft)
          );
          const ratios = [
            { label: "1:1 512", width: 512, height: 512 },
            { label: "1:1 768", width: 768, height: 768 },
            { label: "3:4", width: 576, height: 768 },
            { label: "4:3", width: 768, height: 576 },
            { label: "16:9", width: 960, height: 544 },
            { label: "9:16", width: 576, height: 1024 },
            { label: "4:5", width: 640, height: 800 },
            { label: "5:4", width: 800, height: 640 },
            { label: "3:2", width: 768, height: 512 },
            { label: "2:3", width: 512, height: 768 },
            { label: "16:10", width: 896, height: 560 },
            { label: "5:3", width: 864, height: 512 },
            { label: "2:1", width: 1024, height: 512 },
            { label: "1:2", width: 512, height: 1024 },
            { label: "1:1 1024", width: 1024, height: 1024 },
          ];

          const presets = [
            "a cinematic portrait of a cyberpunk samurai, neon lights, rain, ultra detailed, 8k",
            "sunset over a futuristic city, flying cars, warm light, volumetric fog, anime style",
            "an ancient library with floating books and soft candles, magical realism, high detail",
            "a cozy cat cafe interior, soft focus, pastel colors, photography",
            "a spaceship landing on a lush alien planet, epic scale, vibrant colors, concept art",
          ];

          const successMsg = computed(() => {
            if (!image.value) return "";
            if (loading.value || batchRunning.value || upscaleLoading.value || totalWorkUnits.value > 0) return "";
            if (error.value) return "";
            return t('status.completed');
          });
          const statusLabel = computed(() => {
            if (modelError.value) return `${t('status.loadFailed')}: ${modelError.value}`;
            if (error.value) return `⚠ ${error.value}`;
            if (upscaleError.value) return `⚠ ${upscaleError.value}`;
            if (upscaleLoading.value) return `${t('upscale.running')}...`;
            if (stopRequested.value && (loading.value || batchRunning.value)) return t('status.stopRequested');
            if (batchRunning.value) return t('status.batchGenerating');
            if (loading.value) return t('status.generating');
            if (modelLoading.value) return t('status.loading');
            return t('status.ready');
          });
          const statusTone = computed(() => {
            if (modelError.value) return "var(--danger)";
            if (loading.value || modelLoading.value || batchRunning.value || upscaleLoading.value) {
              return "var(--accent)";
            }
            return "var(--success)";
          });
          const perImagePercent = computed(() => {
            if (!loading.value && !batchRunning.value) return 0;
            const { current, total } = stepProgress.value;
            if (!total) return loading.value ? 5 : 0;
            return Math.min(100, Math.max(0, +((current / total) * 100).toFixed(1)));
          });

          const progressPercent = computed(() => {
            if (!loading.value && !batchRunning.value) return 0;
            const { current, total } = stepProgress.value;
            if (batchRunning.value && batchTotal.value > 0) {
              const batchProgress = Math.max(0, Math.min(batchCursor.value - 1, batchTotal.value));
              const per = total ? current / total : 0;
              const overall = ((batchProgress + per) / batchTotal.value) * 100;
              return Math.min(100, Math.max(0, +overall.toFixed(1)));
            }
            return perImagePercent.value;
          });
          const upscaleProgressPercent = computed(() => {
            if (!upscaleLoading.value) return 0;
            const { current, total } = upscaleStepProgress.value;
            if (total) {
              return Math.min(100, Math.max(0, +((current / total) * 100).toFixed(1)));
            }
            return 30;
          });
          const upscaleProgressLabel = computed(() => {
            if (!upscaleLoading.value) return "";
            const pct = Math.min(100, Math.max(0, Math.round(upscaleProgressPercent.value)));
            return `${pct}%`;
          });

          const imageProgressLabel = computed(() => {
            if (!loading.value) return "";
            const pct = Math.min(100, Math.max(0, Math.round(perImagePercent.value)));
            return `${pct}%`;
          });
          const progressLabel = computed(() => {
            const { current, total } = stepProgress.value;
            if (!loading.value && !batchRunning.value) return "";
            if (!total) return t('status.generating');
            const pct = Math.min(100, Math.max(0, Math.round(progressPercent.value)));
            return `${pct}%`;
          });
          const overallProgressActive = computed(
            () => {
              if (totalWorkUnits.value > 0) {
                const done = Math.min(totalWorkUnits.value, completedWorkUnits.value);
                const activePhase = currentWorkPhase.value === "generate" || currentWorkPhase.value === "upscale";
                return done < totalWorkUnits.value || activePhase || loading.value || batchRunning.value || upscaleLoading.value;
              }
              return loading.value || batchRunning.value || upscaleLoading.value;
            }
          );
          const overallProgressPercent = computed(() => {
            if (totalWorkUnits.value > 0) {
              const done = Math.min(totalWorkUnits.value, completedWorkUnits.value);
              const active =
                currentWorkPhase.value === "generate"
                  ? perImagePercent.value / 100
                  : currentWorkPhase.value === "upscale"
                    ? upscaleProgressPercent.value / 100
                    : 0;
              const pct = ((done + active) / Math.max(1, totalWorkUnits.value)) * 100;
              return Math.min(100, Math.max(0, +pct.toFixed(1)));
            }
            if (loading.value || batchRunning.value) return progressPercent.value;
            if (upscaleLoading.value) return upscaleProgressPercent.value;
            return 0;
          });
          const overallProgressLabel = computed(() => {
            if (totalWorkUnits.value > 0) {
              const pct = Math.min(100, Math.max(0, Math.round(overallProgressPercent.value)));
              return `${pct}%`;
            }
            if (loading.value || batchRunning.value) return progressLabel.value;
            if (upscaleLoading.value) return upscaleProgressLabel.value;
            return "";
          });
          const isGenerateDisabled = computed(
            () => loading.value || modelLoading.value || !!modelError.value || batchRunning.value
          );

          const resetPrompt = () => {
            prompt.value = DEFAULT_PROMPT;
            negativePrompt.value = "";
            guidance.value = 0;
            steps.value = 9;
            height.value = 512;
            width.value = 512;
            seed.value = "";
            batchCount.value = 1;
            results.value = [];
            selectedImage.value = "";
            selectedIndex.value = 0;
            autoUpscaleEnabled.value = false;
            lastAutoBaseId.value = "";
            stepProgress.value = { current: 0, total: 0 };
          };

          const randomizeSeed = () => {
            seed.value = Math.floor(Math.random() * 1_000_000);
          };

          const fallbackGenerateOnce = async (payload) => {
            // 非流式兜底：直接等完整响应，避免 SSE 被中间件/代理切断
            const res = await fetch("/generate", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (!res.ok) {
              const text = await res.text();
              throw new Error(text || "Fallback generate failed");
            }
            const data = await res.json();
            stepProgress.value = { current: payload.steps || steps.value || 0, total: payload.steps || steps.value || 0 };
            return data;
          };

          const streamGenerateOnce = async (payload) => {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), STREAM_TIMEOUT_MS);
            const cleanup = () => clearTimeout(timeout);
            try {
              const res = await fetch("/generate_stream", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
                signal: controller.signal,
              });
              if (!res.ok || !res.body) {
                const text = await res.text();
                throw new Error(text || "Failed to start generation");
              }
              const reader = res.body.getReader();
              const decoder = new TextDecoder();
              let buffer = "";
              let lastEventAt = Date.now();
              let finished = false;

              const promise = new Promise((resolve, reject) => {
                const handleEvent = (eventName, data) => {
                  lastEventAt = Date.now();
                  if (eventName === "progress") {
                    const step = Number(data?.step || 0);
                    const total = Number(data?.total_steps || payload.steps || steps.value || 0);
                    stepProgress.value = { current: step, total };
                    if (data?.note === "no_callback") {
                      startFakeProgress(total);
                    } else {
                      clearFakeProgress();
                    }
                  } else if (eventName === "complete") {
                    stepProgress.value = { current: payload.steps || steps.value || 0, total: payload.steps || steps.value || 0 };
                    clearFakeProgress();
                    finished = true;
                    reader.cancel().catch(() => {});
                    resolve(data);
                  } else if (eventName === "error") {
                    clearFakeProgress();
                    finished = true;
                    reader.cancel().catch(() => {});
                    reject(new Error(data?.error || "Generation failed"));
                  }
                };

                const processBuffer = () => {
                  let idx;
                  while ((idx = buffer.indexOf("\n\n")) !== -1) {
                    const rawEvent = buffer.slice(0, idx).trim();
                    buffer = buffer.slice(idx + 2);
                    if (!rawEvent) continue;
                    const lines = rawEvent.split("\n");
                    let eventName = "message";
                    let dataLines = [];
                    for (const line of lines) {
                      if (line.startsWith("event:")) eventName = line.slice(6).trim();
                      else if (line.startsWith("data:")) dataLines.push(line.slice(5).trim());
                    }
                    const dataStr = dataLines.join("\n");
                    let parsed = {};
                    try {
                      parsed = dataStr ? JSON.parse(dataStr) : {};
                    } catch {
                      parsed = {};
                    }
                    handleEvent(eventName, parsed);
                  }
                };

                const pump = async () => {
                  try {
                    while (true) {
                      if (finished) return;
                      if (Date.now() - lastEventAt > STREAM_TIMEOUT_MS) {
                        throw new Error("stream timeout");
                      }
                      const { value, done } = await reader.read();
                      if (done) break;
                      buffer += decoder.decode(value, { stream: true });
                      processBuffer();
                    }
                    if (!finished) {
                      reject(new Error("Connection closed before completion"));
                    }
                  } catch (err) {
                    clearFakeProgress();
                    reject(err);
                  }
                };

                pump();
              });

              return await promise;
            } catch (err) {
              clearFakeProgress();
              const aborted = controller.signal.aborted || /abort|timeout/i.test(err?.message || "");
              try {
                return await fallbackGenerateOnce(payload);
              } catch (fallbackErr) {
                if (aborted) {
                  throw new Error(t('status.generating') + " timeout");
                }
                throw fallbackErr;
              }
            } finally {
              cleanup();
            }
          };

          const applyRatio = (ratio) => {
            width.value = ratio.width;
            height.value = ratio.height;
            snapDimensions();
          };

          const onRatioChange = () => {
            const ratio = ratios.find((r) => r.label === selectedRatio.value);
            if (ratio) applyRatio(ratio);
          };

          const sanitizeDimension = (v) => {
            const num = Number(v);
            if (!Number.isFinite(num) || num <= 0) return 512;
            return Math.max(512, Math.min(1024, Math.floor(num / 16) * 16));
          };

          const snapDimensions = () => {
            const snap = (v) => {
              return sanitizeDimension(v);
            };
            width.value = snap(width.value);
            height.value = snap(height.value);
            return { width: width.value, height: height.value };
          };

          const sanitizeBatchCount = (v) => {
            const num = Number(v);
            if (!Number.isFinite(num) || num <= 0) return 1;
            return Math.max(1, Math.min(10, Math.floor(num)));
          };

          onMounted(() => {
            const pick = presets[Math.floor(Math.random() * presets.length)];
            if (pick) {
              prompt.value = pick;
            }
            selectedRatio.value = ratios[0]?.label || selectedRatio.value;
            onRatioChange();
          });

          const addToHistory = (payload) => {
            const entry = {
              id: Date.now().toString(36) + Math.random().toString(36).slice(2, 6),
              image: payload.image,
              prompt: payload.meta.prompt || "",
              negative: payload.meta.negative_prompt,
              steps: payload.meta.steps,
              guidance: payload.meta.guidance,
              width: payload.meta.width,
              height: payload.meta.height,
              seed: payload.meta.seed,
              type: payload.meta.type || "generate",
              scale: payload.meta.scale || 1,
            };
            const nextHistory = [...history.value, entry].slice(-12);
            if (previewOpen.value && previewSource.value === "history") {
              selectedIndex.value = Math.max(0, Math.min(selectedIndex.value, nextHistory.length - 1));
            }
            history.value = nextHistory;
          };

          const makeFilename = (targetMeta, fallbackIndex = 0) => {
            const saved = targetMeta?.saved_path;
            if (saved) {
              return saved.split(/[\\/]/).pop() || `zimage_${fallbackIndex + 1}.png`;
            }
            const stamp = new Date().toISOString().replace(/[-:T]/g, "").slice(0, 15);
            return `zimage_${stamp}_${fallbackIndex + 1}.png`;
          };

          const downloadImage = () => {
            if (!results.value.length) return;
            results.value.forEach((item, idx) => {
              const link = document.createElement("a");
              link.href = item.image;
              link.download = makeFilename(item.meta, idx);
              link.click();
            });
          };

          const downloadPreviewImage = () => {
            const item = currentPreviewItem.value;
            if (!item) return;
            const link = document.createElement("a");
            link.href = item.image;
            link.download = makeFilename(item.meta || item, selectedIndex.value);
            link.click();
          };

          const onMagnifierMove = (event) => {
            if (!magnifierEnabled.value) return;
            const img = event.currentTarget;
            if (!img) return;
            magnifierPending = {
              clientX: event.clientX,
              clientY: event.clientY,
              rect: img.getBoundingClientRect(),
              naturalWidth: img.naturalWidth || img.getBoundingClientRect().width,
              naturalHeight: img.naturalHeight || img.getBoundingClientRect().height,
              src: img.src,
            };
            if (!magnifierRAF) {
              magnifierRAF = requestAnimationFrame(() => {
                if (!magnifierPending) {
                  magnifierRAF = null;
                  return;
                }
                const { clientX, clientY, rect, naturalWidth, naturalHeight, src } = magnifierPending;
                magnifierPending = null;
                magnifierRAF = null;
                if (!magnifierEnabled.value) return;
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                magnifierData.value = {
                  bgX: (x / rect.width) * naturalWidth,
                  bgY: (y / rect.height) * naturalHeight,
                  naturalWidth,
                  naturalHeight,
                  clientX,
                  clientY,
                };
                magnifierImage.value = src;
                magnifierVisible.value = true;
              });
            }
          };

          const hideMagnifier = () => {
            magnifierVisible.value = false;
          };

          const onPreviewWheel = (event) => {
            event.preventDefault();
            const delta = event.deltaY;
            const step = delta > 0 ? -0.2 : 0.2;
            const next = Math.min(5, Math.max(1, +(magnifierZoom.value + step).toFixed(2)));
            magnifierZoom.value = next;
          };

          const pickUpscaleSource = () => {
            if (currentPreviewItem.value?.image) return { image: currentPreviewItem.value.image, meta: currentPreviewItem.value.meta || currentPreviewItem.value };
            if (results.value[selectedIndex.value]?.image) return { image: results.value[selectedIndex.value].image, meta: results.value[selectedIndex.value].meta || results.value[selectedIndex.value] };
            if (results.value.length > 0) return { image: results.value[0].image, meta: results.value[0].meta || results.value[0] };
            if (selectedImage.value) return { image: selectedImage.value, meta: meta.value || {} };
            if (image.value) return { image: image.value, meta: meta.value || {} };
            return { image: "", meta: {} };
          };

          const fallbackUpscaleOnce = async (payload) => {
            const res = await fetch("/upscale", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (!res.ok) {
              const text = await res.text();
              throw new Error(text || "Upscale failed");
            }
            const data = await res.json();
            upscaleStepProgress.value = { current: 1, total: 1 };
            return data;
          };

          const streamUpscale = async (payload, isAuto = false) => {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), UPSCALE_TIMEOUT_MS);
            const cleanup = () => clearTimeout(timeout);
            try {
              const res = await fetch("/upscale_stream", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
                signal: controller.signal,
              });
              if (!res.ok || !res.body) {
                const text = await res.text();
                throw new Error(text || "Failed to start upscale");
              }
              const reader = res.body.getReader();
              const decoder = new TextDecoder();
              let buffer = "";
              let finished = false;
              const data = await new Promise((resolve, reject) => {
                const handleEvent = (eventName, data) => {
                  if (eventName === "progress") {
                    const current = Number(data?.current || 0);
                    const total = Number(data?.total || 0) || current || 1;
                    upscaleStepProgress.value = { current, total };
                    return;
                  }
                  if (eventName === "result") {
                    const current = upscaleStepProgress.value.current || 1;
                    const total = upscaleStepProgress.value.total || current || 1;
                    upscaleStepProgress.value = { current: total, total };
                    finished = true;
                    reader.cancel().catch(() => {});
                    resolve(data);
                    return;
                  }
                  if (eventName === "error") {
                    finished = true;
                    reader.cancel().catch(() => {});
                    reject(new Error(data?.message || "Upscale failed"));
                  }
                };
                const read = () => {
                  reader.read().then(({ done, value }) => {
                    if (done) {
                      if (!finished) {
                        reject(new Error("Upscale interrupted"));
                      }
                      return;
                    }
                    buffer += decoder.decode(value, { stream: true });
                    const parts = buffer.split("\n\n");
                    buffer = parts.pop() || "";
                    for (const chunk of parts) {
                      const lines = chunk.split("\n");
                  const eventLine = lines.find((line) => line.startsWith("event:"));
                  const dataLine = lines.find((line) => line.startsWith("data:"));
                  if (!eventLine || !dataLine) continue;
                  const eventName = eventLine.replace("event:", "").trim();
                  const dataRaw = dataLine.replace("data:", "").trim();
                      let data;
                      try {
                        data = JSON.parse(dataRaw);
                      } catch (err) {
                        data = {};
                      }
                      handleEvent(eventName, data);
                  }
                  read();
                }).catch((err) => {
                  finished = true;
                  reader.cancel().catch(() => {});
                  reject(err);
                });
              };
              read();
            });
            return data;
            } catch (err) {
              const aborted = controller.signal.aborted || /abort|timeout/i.test(err?.message || "");
              if (aborted) {
                throw new Error(t('upscale.running') + " timeout");
              }
              // fallback to non-stream upscale on any other failure
              return await fallbackUpscaleOnce(payload);
            } finally {
              cleanup();
            }
          };

          const upscaleImage = async ({ auto = false, sourceOverride = null } = {}) => {
            const sourcePayload = sourceOverride || pickUpscaleSource();
            if (!sourcePayload.image) {
              upscaleError.value = t('upscale.noImage');
              return;
            }
            upscaleLoading.value = true;
            upscaleError.value = "";
            upscaleStepProgress.value = { current: 0, total: 0 };
            if (auto) {
              currentWorkPhase.value = "upscale";
            } else {
              if (totalWorkUnits.value === 0) {
                totalWorkUnits.value = 1;
                completedWorkUnits.value = 0;
              }
              currentWorkPhase.value = "upscale";
            }
            try {
              const data = await streamUpscale({
                image: sourcePayload.image,
                scale: upscaleScale.value,
              }, auto);
              const baseMeta = sourcePayload.meta || {};
              const meta = {
                ...baseMeta,
                ...(data.meta || {}),
                type: "upscale",
                scale: (data.meta && (data.meta.applied_scale || data.meta.scale)) || upscaleScale.value,
                prompt: baseMeta.prompt || prompt.value || "",
                negative_prompt: baseMeta.negative_prompt || negativePrompt.value || "",
                steps: baseMeta.steps ?? steps.value,
                guidance: baseMeta.guidance ?? guidance.value,
                seed: baseMeta.seed ?? null,
              };
              const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
              const newItem = { id, image: data.image, meta };
              const limit = autoUpscaleEnabled.value ? 24 : 12;
              const nextResults = [...results.value, newItem].slice(-limit);
              results.value = nextResults;
              addToHistory({ image: data.image, meta: { ...meta, scale: meta.applied_scale || meta.scale || upscaleScale.value } });
            } catch (err) {
              upscaleError.value = err.message || "";
            } finally {
              upscaleLoading.value = false;
              if (auto) {
                completedWorkUnits.value = Math.min(
                  totalWorkUnits.value,
                  completedWorkUnits.value + 1
                );
              } else if (totalWorkUnits.value > 0 && completedWorkUnits.value < totalWorkUnits.value) {
                completedWorkUnits.value += 1;
              }
              if (totalWorkUnits.value > 0 && completedWorkUnits.value >= totalWorkUnits.value) {
                finalizeWork();
              } else {
                currentWorkPhase.value = "";
              }
              upscaleStepProgress.value = { current: 0, total: 0 };
            }
          };

          const toggleAutoUpscale = () => {
            autoUpscaleEnabled.value = !autoUpscaleEnabled.value;
          };

          watch(
            magnifierEnabled,
            (enabled) => {
              if (!enabled) {
                magnifierVisible.value = false;
                magnifierPending = null;
                if (magnifierRAF) {
                  cancelAnimationFrame(magnifierRAF);
                  magnifierRAF = null;
                }
              }
            },
            { immediate: false }
          );

          watch(
            magnifierDisabled,
            (disabled) => {
              if (disabled && magnifierEnabled.value) {
                toggleMagnifier();
              }
            },
            { immediate: true }
          );

          const toggleMagnifier = () => {
            magnifierEnabled.value = !magnifierEnabled.value;
            if (!magnifierEnabled.value) {
              hideMagnifier();
            }
          };

          const deleteResult = (id) => {
            const idx = results.value.findIndex((r) => r.id === id);
            if (idx === -1) return;
            const next = results.value.filter((r) => r.id !== id);
            results.value = next;
            if (previewOpen.value && previewSource.value === "results") {
              if (!next.length) {
                previewOpen.value = false;
                selectedImage.value = "";
                selectedIndex.value = 0;
                return;
              }
              if (selectedIndex.value >= next.length) {
                selectedIndex.value = next.length - 1;
              }
              selectedImage.value = next[selectedIndex.value]?.image || "";
            }
          };


          const requestStop = () => {
            if (loading.value || batchRunning.value) {
              stopRequested.value = true;
            }
          };

          watch(
            () => completedWorkUnits.value,
            () => {
              if (!autoUpscaleEnabled.value && !loading.value && !batchRunning.value && !upscaleLoading.value) {
                totalWorkUnits.value = 0;
                currentWorkPhase.value = "";
                completedWorkUnits.value = 0;
              }
            }
          );

          // Keep scroll-card heights aligned with the prompt card when content/state changes

          const previewItems = computed(() => (previewSource.value === "history" ? history.value : results.value));

          const currentPreviewItem = computed(() => {
            const list = previewItems.value;
            if (!list.length) return null;
            return list[selectedIndex.value] || list[0];
          });

          const canUpscale = computed(() => {
            return (
              !!(currentPreviewItem.value && currentPreviewItem.value.image) ||
              !!selectedImage.value ||
              !!image.value ||
              results.value.length > 0
            );
          });
          const upscaleDisabled = computed(() => !canUpscale.value || upscaleLoading.value || loading.value || batchRunning.value);

          const magnifierStyle = computed(() => {
            if (!magnifierVisible.value || !magnifierEnabled.value) return {};
            const { bgX, bgY, naturalWidth, naturalHeight, clientX, clientY } = magnifierData.value;
            if (!naturalWidth || !naturalHeight) return {};
            const size = magnifierSize.value;
            const zoom = magnifierZoom.value;
            const backgroundSize = `${naturalWidth * zoom}px ${naturalHeight * zoom}px`;
            const backgroundPosition = `${size / 2 - bgX * zoom}px ${size / 2 - bgY * zoom}px`;
            return {
              width: `${size}px`,
              height: `${size}px`,
              left: `${clientX - size / 2}px`,
              top: `${clientY - size / 2}px`,
              backgroundImage: `url(${magnifierImage.value || (currentPreviewItem.value && currentPreviewItem.value.image) || ""})`,
              backgroundRepeat: "no-repeat",
              backgroundSize,
              backgroundPosition,
            };
          });

          const hasPrev = computed(() => selectedIndex.value > 0 && previewItems.value.length > 0);
          const hasNext = computed(() => selectedIndex.value < previewItems.value.length - 1);

          const prevImage = () => {
            if (!hasPrev.value) return;
            selectedIndex.value -= 1;
            const item = currentPreviewItem.value;
            selectedImage.value = item?.image || "";
            magnifierImage.value = item?.image || "";
          };

          const nextImage = () => {
            if (!hasNext.value) return;
            selectedIndex.value += 1;
            const item = currentPreviewItem.value;
            selectedImage.value = item?.image || "";
            magnifierImage.value = item?.image || "";
          };

          const openPreview = (idx = 0, source = "results") => {
            previewSource.value = source;
            const list = source === "history" ? history.value : results.value;
            if (!list.length) return;
            const index = Math.max(0, Math.min(list.length - 1, idx));
            const item = list[index];
            if (!item) return;
            selectedIndex.value = index;
            selectedImage.value = item.image;
            magnifierImage.value = item.image;
            previewOpen.value = true;
          };

          const closePreview = () => {
            previewOpen.value = false;
            magnifierVisible.value = false;
            showInfoOverlay.value = false;
          };

          const generateOnce = async (overrides = {}) => {
            // 忽略按钮事件对象，保证不会把 PointerEvent.width/height=1 当成尺寸
            if (overrides instanceof Event) {
              overrides = {};
            }
            // 确保发送前尺寸已对齐、在有效范围内
            const aligned = (() => {
              const resolvedHeight = overrides.height ?? height.value;
              const resolvedWidth = overrides.width ?? width.value;
              const h = sanitizeDimension(resolvedHeight);
              const w = sanitizeDimension(resolvedWidth);
              if (overrides.height === undefined) {
                height.value = h;
              }
              if (overrides.width === undefined) {
                width.value = w;
              }
              return { height: h, width: w };
            })();

            const payload = {
              prompt: overrides.prompt ?? prompt.value,
              negative_prompt: overrides.negative_prompt ?? negativePrompt.value,
              steps: overrides.steps ?? steps.value,
              guidance: overrides.guidance ?? guidance.value,
              height: aligned.height,
              width: aligned.width,
            };

            const seedVal = overrides.seed ?? seed.value;
            if (seedVal !== "") {
              payload.seed = Number(seedVal);
            }

            stepProgress.value = { current: 0, total: payload.steps || steps.value || 0 };
            currentWorkPhase.value = "generate";

            try {
              const data = await streamGenerateOnce(payload);
              image.value = data.image;
              meta.value = data.meta || null;
              const id = Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
              const limit = autoUpscaleEnabled.value ? 24 : 12;
              const nextResults = [...results.value, { id, image: data.image, meta: data.meta || {} }].slice(-limit);
              if (previewOpen.value && previewSource.value === "results") {
                selectedIndex.value = Math.max(0, Math.min(selectedIndex.value, nextResults.length - 1));
              } else {
                selectedImage.value = data.image;
              }
              results.value = nextResults;
              addToHistory(data);
              completedWorkUnits.value = Math.min(
                totalWorkUnits.value,
                completedWorkUnits.value + 1
              );
              return data;
            } catch (err) {
              error.value = err.message || "生成失败";
              return null;
            }
          };

          const generate = async (overrides = {}) => {
            if (overrides instanceof Event) overrides = {};
            const count = sanitizeBatchCount(batchCount.value);
            batchCount.value = count;
            const seedWasEmpty = seed.value === "";
            const fixedSeed = seedWasEmpty ? null : seed.value;
            const alignedDims = (() => {
              const baseHeight = overrides.height ?? height.value;
              const baseWidth = overrides.width ?? width.value;
              const safeHeight = sanitizeDimension(baseHeight);
              const safeWidth = sanitizeDimension(baseWidth);
              if (overrides.height === undefined) {
                height.value = safeHeight;
              }
              if (overrides.width === undefined) {
                width.value = safeWidth;
              }
              return { height: safeHeight, width: safeWidth };
            })();
            const fixedParams = {
              prompt: overrides.prompt ?? prompt.value,
              negative_prompt: overrides.negative_prompt ?? negativePrompt.value,
              steps: overrides.steps ?? steps.value,
              guidance: overrides.guidance ?? guidance.value,
              width: alignedDims.width,
              height: alignedDims.height,
            };

            if (loading.value || batchRunning.value) {
              return false;
            }
            if (modelLoading.value) {
              error.value = t('status.loading');
              return false;
            }
            if (modelError.value) {
              error.value = `模型加载失败: ${modelError.value}`;
              return false;
            }

            error.value = "";
            loading.value = true;
            batchRunning.value = count > 1;
            batchTotal.value = count;
            batchCursor.value = 0;
            stopRequested.value = false;
            meta.value = null;
            results.value = [];
            selectedImage.value = "";
            totalWorkUnits.value = count * (autoUpscaleEnabled.value ? 2 : 1);
            completedWorkUnits.value = 0;
            currentWorkPhase.value = "generate";
            let failedCount = 0;

            for (let i = 0; i < count; i += 1) {
              batchCursor.value = i + 1;
              const nextSeed =
                overrides.seed !== undefined
                  ? overrides.seed
                  : seedWasEmpty
                    ? Math.floor(Math.random() * 1_000_000)
                    : fixedSeed;
              // 若用户未填写种子，则保持输入框为空，但每次循环使用新的随机种子
              if (!seedWasEmpty) {
                seed.value = nextSeed; // 保持用户输入的固定种子
              }
              const data = await generateOnce({ ...fixedParams, seed: nextSeed });
              if (!data) {
                failedCount += 1;
                continue;
              }
              if (stopRequested.value) break;
              if (autoUpscaleEnabled.value) {
                const sourcePayload = { image: data.image, meta: data.meta || {} };
                await upscaleImage({ auto: true, sourceOverride: sourcePayload });
                if (stopRequested.value) break;
              }
            }

            loading.value = false;
            batchRunning.value = false;
            batchCursor.value = 0;
            batchTotal.value = 0;
            stopRequested.value = false;
            finalizeWork();
            if (failedCount > 0) {
              error.value = `有 ${failedCount} 张生成失败`;
            }
            return true;
          };

          const applyHistory = (item) => {
              prompt.value = item.prompt;
              negativePrompt.value = item.negative || "";
              steps.value = item.steps;
              guidance.value = item.guidance;
              width.value = item.width;
              height.value = item.height;
              seed.value = item.seed ?? "";
              image.value = item.image;
              meta.value = {
                prompt: item.prompt,
                negative_prompt: item.negative,
                steps: item.steps,
                guidance: item.guidance,
                height: item.height,
                width: item.width,
                seed: item.seed,
              };
          };

          const regenerate = (item) => {
            applyHistory(item);
            generate({
              prompt: item.prompt,
              negative_prompt: item.negative,
              steps: item.steps,
              guidance: item.guidance,
              width: item.width,
              height: item.height,
              seed: item.seed ?? "",
            });
          };

          const deleteHistory = (id) => {
            history.value = history.value.filter((x) => x.id !== id);
          };

          const clearHistory = () => {
            history.value = [];
          };

          const checkHealth = async () => {
            try {
              const res = await fetch("/health");
              if (!res.ok) throw new Error();
              const data = await res.json();
              if (data.pipeline_error) {
                modelError.value = data.pipeline_error;
                modelLoading.value = false;
                return;
              }
              if (data.pipeline_ready) {
                modelLoading.value = false;
                return;
              }
            } catch (err) {
              // swallow errors; will retry
            }
            setTimeout(checkHealth, 1200);
          };

          checkHealth();

          return {
            prompt,
            negativePrompt,
            steps,
            guidance,
            height,
            width,
            seed,
            loading,
            modelLoading,
            modelError,
            statusLabel,
            statusTone,
            error,
            meta,
            image,
            presets,
            successMsg,
            ratios,
            selectedRatio,
            history,
            results,
            generate,
            randomizeSeed,
            resetPrompt,
            downloadImage,
            previewOpen,
            openPreview,
            closePreview,
            applyRatio,
            selectedImage,
            selectedIndex,
            previewSource,
            currentPreviewItem,
            canUpscale,
            upscaleDisabled,
            magnifierVisible,
            magnifierStyle,
            onMagnifierMove,
            hideMagnifier,
            onPreviewWheel,
            promptCardRef,
            syncedCardStyle,
            upscaleScale,
            upscaleLoading,
            upscaleError,
            upscaleStepProgress,
            upscaleImage,
            streamUpscale,
            hasPrev,
            hasNext,
            prevImage,
            nextImage,
            downloadPreviewImage,
            generateOnce,
            onRatioChange,
            snapDimensions,
            batchCount,
            batchRunning,
            batchCursor,
            batchTotal,
            stopRequested,
            isGenerateDisabled,
            progressPercent,
            imageProgressLabel,
            progressLabel,
            totalWorkUnits,
            completedWorkUnits,
            currentWorkPhase,
            upscaleProgressPercent,
            upscaleProgressLabel,
            applyHistory,
            regenerate,
            deleteHistory,
            clearHistory,
            currentLang,
            t,
            switchLanguage,
            themeOptions,
            activeTheme,
            activeThemeLabel,
            activeThemeSwatch,
            themeMenuOpen,
            themeSwitchRef,
            themeControlWidth,
            syncThemeWidth,
            getThemeSwatch,
            toggleThemeMenu,
            selectTheme,
            requestStop,
            autoUpscaleEnabled,
            toggleAutoUpscale,
            magnifierEnabled,
            magnifierDisabled,
            toggleMagnifier,
            deleteResult,
            overallProgressActive,
            overallProgressPercent,
            overallProgressLabel,
            showInfoOverlay,
          };
        },
      })
        .use(ElementPlus)
        .mount("#app");
    </script>
  </body>
</html>
